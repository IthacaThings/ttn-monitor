#!/usr/bin/env python3

from __future__ import print_function
import argparse
import copy
import datetime
import logging
import os
import pprint
import re
import smtplib
import subprocess
import sys
import time

from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

from dateutil.tz import tzlocal, tzoffset

import geopy.distance

try:
    import cPickle as pickle
except ImportError:
    import pickle

try:
    import yaml
except ImportError:
    print("Please install PyYaml", file=sys.stderr)
    sys.exit(1)


"""
MIT License

Copyright (c) 2017,2018 Jeffrey C Honig

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

# Link for getting a token
_REGISTER_URL = "https://account.thethingsnetwork.org/users/authorize?client_id=ttnctl&redirect_uri=/oauth/callback/ttnctl&response_type=code"

# Remove ANSI terminal sequences
_ANSI_RE = re.compile(r'\x1b\[\d+[A-Za-z]')
# Extract key and value
_INFO_RE = re.compile(r"^\s+(?P<key>[A-za-z ]+):\s(?P<value>.*)\s*$")


def sendmail(options, to, cc, subject, body):
    ''' Do the work of sending mail '''

    dest = set()
    if options.test:
        dest.add(options.fromaddr)
    else:
        dest.add(to)
        dest.update(cc)

    msg = MIMEMultipart('alternative')
    msg['Subject'] = subject
    msg['From'] = options.fromaddr
    msg['To'] = to
    msg['Cc'] = ", ".join(cc)
    msg.attach(MIMEText("\n\n".join(body), 'plain'))

    logging.debug("MAIL: From: %s To: %s Cc: %s Subject: %s",
                  msg.get('From'),
                  msg.get('To'),
                  msg.get('Cc'),
                  msg.get('Subject'))
    logging.debug("SENDMAIL(%s -> %s)",
                  options.fromaddr, ",".join(dest))
    try:
        server = smtplib.SMTP('localhost')
    except ConnectionRefusedError:
        logging.error('Unable to send mail')
        return

    try:
        #        server.set_debuglevel(True)

        # identify ourselves, prompting server for supported features
        server.ehlo()

        # If we can encrypt this session, do it
        if server.has_extn('STARTTLS'):
            server.starttls()
            server.ehlo() # re-identify ourselves over TLS connection

        resp = server.sendmail(options.fromaddr, dest, msg.as_string())
        logging.debug("SENDMAIL: %s", resp)
    finally:
        server.quit()

class Config(object):
    """ Config file parsing """

    class ParseError(Exception):
        """ Handle a Parse Error """
        pass

    def __init__(self, options):
        self._options = options
        self._defaults = dict()
        self._groups = dict()
        self._gateways = dict()
        self._gateway_group = dict()

        # To deal with adding help option with multi-stage
        if self._options.help:
            return

        # Read the config file
        if self._options.config:
            config_files = [options.config]
        else:
            config_files = ['./.ttn-monitor.yaml', '~/.ttn-monitor.yaml']
        for config_file in config_files:
            try:
                logging.debug("Reading %s", config_file)
                self._config_load(os.path.expanduser(config_file))
            except IOError as error:
                if self._options.debug or self._options.config:
                    logging.warning(error)
                continue
            logging.debug("Parsing %s", config_file)
            self._config_top()
            break

    def _config_load(self, filename):
        """ Read config data as yaml """

        # Open the file
        config_file = open(filename)

        # Parse it
        try:
            self._config_data = yaml.load(config_file, Loader=yaml.Loader)
        except yaml.scanner.ScannerError as err:
            raise self.ParseError("YAML Parse error on %s: %s" % (filename, err))

        # Close it
        config_file.close()

    def _validate(self, config, allowed=[]):
        """ Generic validation """

        for key, value in list(config.items()):
            if key not in allowed:
                raise self.ParseError("invalid Global key: %s" % (key))
            if key == 'cc':
                if isinstance(value, str):
                    config['cc'] = [value]
                elif isinstance(value, list):
                    for val in value:
                        if not isinstance(val, str):
                            raise self.ParseError("%s is not a string" % val)
                else:
                    raise self.ParseError("%s is not a list or string" % value)
            elif key == 'from' or key == 'to':
                if not isinstance(value, str):
                    raise self.ParseError("%s is not a string" % val)
            elif key == 'late':
                if not isinstance(value, (int, float)):
                    raise self.ParseError("%s is not a number" % value)
            elif key == 'timeout':
                if not isinstance(value, (int, float)):
                    raise self.ParseError("%s is not a number" % value)
            elif key == 'test':
                if not isinstance(value, bool):
                    raise self.ParseError("%s is not a boolean" % value)
            elif key == 'alias':
                if not isinstance(value, str):
                    raise self.ParseError("%s is not a string" % value)
            else:
                raise self.ParseError("Internal error parsing %s" % value)

    def _config_top(self):
        """ Parse the top level config items """

        logging.debug("Config: %s",
                      pprint.pformat(self._config_data))

        for group, config in list(self._config_data.items()):
            if group.lower() == "global":
                self._validate(config, ['cc', 'from', 'late', 'timeout', 'test'])
                self._defaults = config
                logging.debug("Config: defaults %s", pprint.pformat(self._defaults))
                continue

            for gateway, value in list(config.items()):
                if gateway.lower() == "defaults":
                    self._validate(value, ['cc', 'to'])
                    self._groups[group] = value
                    logging.debug("Config: %s: %s", group, value)
                else:
                    if not isinstance(gateway, str):
                        self.ParseError("Gateway ID is not a string: %s" % gateway)
                    self._validate(value, ['to', 'cc', 'alias'])
                    self._gateway_group[gateway] = group
                    self._gateways[gateway] = value
                    logging.debug("Config: %s: %s", gateway, pprint.pformat(value))

    def __str__(self):
        """ Show what we have """

        # XXX - Global
        # XXX - Groups
        # XXX - Gateways


    def gateway(self, gw_id):
        ''' Return defaults for a gateway '''

        defaults = dict()
        try:
            group = self._gateway_group[gw_id]
            defaults = copy.copy(self._groups[group])
            for key, value in list(self._gateways[gw_id].items()):
                if key == 'cc':
                    if 'cc' in defaults:
                        logging.debug("XXX 1 %s", defaults[key])
                        defaults[key].extend(value)
                        logging.debug("XXX 2 %s", defaults[key])
                defaults[key] = value
        except KeyError:
            pass

        return defaults

    def default(self, value, default=None):
        ''' Return a default value '''

        logging.debug("Config.default(%s, %s): %s",
                      value,
                      default,
                      self._defaults.get(value, default))
        return self._defaults.get(value, default)

class Notice(object):
    """ Hold a notice """

    def __init__(self, message):
        """ Record a notice """

        self._message = message
        self._timestamp = datetime.datetime.now()

    def __str__(self):
        """ Return message """
        return self._message

    def long(self):
        """ Return timestamp and message """
        return "%s %s" % (self._timestamp.strftime("%F %R %Z"), self._message)

    @property
    def timestamp(self):
        """ Return timestamp """
        return self._timestamp

#
#	Gateway list
#

class UserToken(Exception):
    ''' User exceptions '''
    pass

class UserError(Exception):
    ''' User exceptions '''
    pass

class GatewayError(Exception):
    ''' For gateway exceptions '''
    pass

class Gateway(object):
    """Class to hold Gateway info"""

    # 2017-08-17 18:05:16.935947527 -0400 EDT
    _TIME_RE = re.compile(r'(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})\s+(?P<hour>\d{2}):(?P<minute>\d{2}):(?P<seconds>\d{2})(\.\d+)?\s+(?P<offhour>[+-]\d{2})(?P<offmin>\d{2})\s+(?P<tzname>[A-Z]+)')
    _LOCATION_RE = re.compile(r'\((?P<lat>-?\d+\.\d+),\s*(?P<lon>-?\d+\.\d+);\s+(?P<source>.*)\)$')

    def __init__(self, options, config, gw_id, frequency_plan, latitude, longitude, router):
        """"""
        self._options = options
        self._config = config
        self._activated = False
        self._active = True
        self._collaborators = {}
        self._frequency_plan = frequency_plan
        self._gw_id = gw_id
        self._alias = None
        self._info = {}
        self._info_old = {}
        self._late = datetime.timedelta(0)
        self._latitude = float(latitude)
        self._log = []
        self._longitude = float(longitude)
        self._notices = []
        self._offset = datetime.timedelta(0)
        self._router = router
        self._status_error = {'current': None,
                              'last': None}
        self._status_time = None
        self._was_active = True

    @staticmethod
    def sign(var):
        """ Return sign of var """

        if var > 0:
            return 1
        elif var < 0:
            return -1
        else:
            return 0

    def __repr__(self):
        return "%s: %s %s %s %f, %f %s" % (self._alias or "N/A",
                                           self._gw_id,
                                           self._activated,
                                           self._frequency_plan,
                                           self._latitude,
                                           self._longitude,
                                           self._router)

    def __str__(self):
        return "%s: %s %s %s %f, %f %s" % (self._alias or "N/A",
                                           self._gw_id,
                                           self._activated,
                                           self._frequency_plan,
                                           self._latitude,
                                           self._longitude,
                                           self._router)

    def _get_response(self, *args):
        """ Issue a command and get the response """

        cmd = [self._options.binary]
        cmd.extend(args)

        try:
            logging.debug("DBG: %s", " ".join(cmd))
            lines = subprocess.check_output(cmd, encoding='UTF-8')
        except subprocess.CalledProcessError as err:
            logging.info("ERR: %s returns %d", " ".join(cmd), err.returncode)
            lines = err.output

        collaborators = False
        username = None
        self._collaborators = {}
        for line in lines.split("\n"):
            sline = re.sub(_ANSI_RE, '', line).strip()
            if sline == "":
                continue
            if sline.startswith("INFO"):
                logging.debug("DBG: %s", line)
                continue
            if sline.startswith("FATAL"):
                logging.info(sline)
                if sline.find('Please login with ttnctl user login') != -1:
                    raise UserToken("Go to %s to get an OAuth token" % _REGISTER_URL)
                raise GatewayError(sline)

            if sline == "Collaborators:":
                collaborators = True
                continue

            if collaborators and sline.startswith('- Username: '):
                username = sline.split(': ')[1].strip()
                continue

            match = _INFO_RE.match(line)
            if not match:
                continue

            if collaborators:
                if match.group('key') == "Rights":
                    self._collaborators[username] = match.group('value').split(', ')
                    username = None

            key = match.group('key')
            value = match.group('value')
            if key in ["Description", "Location"]:
                key += '.' + args[1]
            self._info[key] = value

    def info(self):
        """ Return info array """
        return self._info

    def get_info(self):
        """ Get additional info via 'info' subcommand """

        logging.debug("GET INFO: %s", self)

        try:
            self._info_old = copy.copy(self._info)
            self._get_response("gateway", "info", self._gw_id)
        except (UserToken, GatewayError) as err:
            logging.error(err.args[0])

    def get_status(self):
        """ Get additional info via 'info' subcommand """

        logging.debug("GET STATUS: %s", self)

        try:
            cmd = ["gateway", "status", self._gw_id]
            try:
                cmd.extend(["--router-id", self._info['Router']])
            except KeyError:
                pass
            self._get_response(*cmd)
            self._status_error['current'] = None
        except GatewayError as err:
            self._info['Last seen'] = None
            self._info['Reported time'] = None
            self._status_error['current'] = err.args[0]
        except UserToken as err:
            logging.error(err.message)
            return

        self._status_time = datetime.datetime.now(tzlocal())

    def check_status(self):
        ''' Check the status results '''
        if self.status_error_current != self.status_error_last:
            if self.status_error_current:
                self.notice(self.status_error_current)
            else:
                self.notice("Status successfully obtained")
            self.status_error_last = self.status_error_current

        if self.reported_time and self.last_seen:
            offset = self.reported_time - self.last_seen
            if self.sign(offset.total_seconds()) != self.sign(self._offset.total_seconds()):
                # XXX - ahead by 2, behind by 30?
                if abs(offset.total_seconds() > 2):
                    if offset.total_seconds() > 0:
                        if self._offset.total_seconds() <= 0:
                            self.notice("Gateway time is ahead by %s" % offset, logonly=True)
                    elif offset.total_seconds() < 2:
                        if self._offset.total_seconds() > 0:
                            self.notice("Gateway time is behind by %s" % offset, logonly=True)
                elif abs(self.offset.total_seconds()) < 2:
                    if abs(self._offset.total_seconds()) >= 2:
                        self.notice("Gateway time is within 2 seconds", logonly=True)
            self._offset = offset

            late = self.status_time - self.last_seen
            # XXX - Fix logic
            if late.total_seconds() > self._options.late:
                if self._late.total_seconds() < self._options.late:
                    self.notice("No response from gateway in %s" % late)
            elif late.total_seconds() <= self._options.late:
                if self._late.total_seconds() >= self._options.late:
                    self.notice("Gateway is now responding")
            self._late = late

        for key in ['Antenna',
                    'Brand',
                    'Bridge',
                    'Contact email'
                    'Description.info',
                    'Description.status',
                    'Frequency Plan',
                    'IP Address',
                    'Location.info',
                    'Location.status',
                    'Model',
                    'Owner',
                    'Placement',
                    'Platform',
                    'Router']:
            try:
                result = None
                if self._info_old[key] != self._info[key]:
                    msg = '"%s" changed "%s" -> "%s"' % (key,
                                                         self._info_old[key],
                                                         self._info[key])
                    if key.startswith('Location.'):
                        result = self._location_match(key)
                        if result == False:
                            continue
                    if result:
                        msg += ": " + result
                    self.notice(msg)
            except KeyError:
                pass

    def _location_match(self, key):
        """ Compare location for a less picky match """

        result = []
        match = self._LOCATION_RE.match(self._info[key])
        if not match:
            return None
        old_match = self._LOCATION_RE.match(self._info_old[key])
        if not old_match:
            return None
        if match.group('source') != old_match.group('source'):
            result.append('Source changed')
        old = (float(old_match.group('lat')), float(old_match.group('lon')))
        new = (float(match.group('lat')), float(match.group('lon')))
        distance = geopy.distance.vincenty(old, new)
        if distance.feet > 1000:
            result.append("moved %.2f miles" % distance.miles)
        elif distance.feet > 100:
            result.append("moved %.0f feet" % distance.feet)

        if not result:
            return False

        return ", ".join(result)
                                
    def pretty(self):
        ''' Pretty print a bunch of gateway info '''

        lines = []
        for key in ['%Overview',
                    'Gateway ID',
                    'Description.info',
                    'Owner',
                    'Frequency Plan',
                    'Router',
                    'Last seen',
                    'Reported time',
                    '%Config',
                    '%Status',
                    'Description.status',
                    'Contact email',
                    'Bridge',
                    'IP Address',
                    'Rtt',
                    'Rx',
                    'Tx',
                    'Location.status',
                    '%Information',
                    'Brand',
                    'Platform',
                    'Model',
                    'Antenna',
                    '%Location',
                    'Placement',
                    'Location.info',
                    '%Privacy',
                    'Status Public',
                    'Location Public',
                    'Owner Public']:
            if key == '%Config':
                lines.append("\tConfig:")
                config = self._config.gateway(self.gw_id)
                for key in sorted(config.keys()):
                    value = config.get(key)
                    if isinstance(value, list):
                        value = ", ".join(value)
                    lines.append("\t\t%15s: %s" % (key.capitalize(), value))
            elif key.startswith('%'):
                lines.append("\t%s:" % key[1:])
            else:
                desc = key
                if desc == 'Last seen':
                    if self.last_seen:
                        value = "%d seconds ago" % (self.status_time - self.last_seen).total_seconds()
                    else:
                        value = "N/A"
                elif desc == 'Reported time':
                    value = self.reported_time if self.reported_time else "N/A"
                else:
                    value = self._info.get(desc, "N/A")
                    if desc.endswith('.info') or desc.endswith('.status'):
                        desc, x, x = desc.partition('.')
                lines.append("\t\t%15s: %s" % (desc, value))

        return lines

    def is_active(self):
        ''' Are we active '''
        return self._active

    def active(self):
        ''' Mark active '''
        self._active = True

    def notice(self, msg, logonly=False):
        ''' Add a notice '''

        if not msg:
            return

        notice = Notice(msg)
        logging.debug("NOTICE: %s", notice)
        if not logonly:
            self._notices.append(notice)
        self._log.append("%s %s" % (datetime.datetime.now(tzlocal()).strftime("%F %R %Z"), notice))

    def notices(self):
        ''' Read notices '''
        return self._notices

    @property
    def log(self):
        ''' Read log '''
        return self._log

    def clear(self):
        ''' Clear notices '''
        self._notices = []

    @property
    def was_active(self):
        ''' Was active last time '''
        return self._was_active

    def save_active(self):
        ''' Set was active last time '''
        self._was_active = self._active
        self._active = False

    @property
    def status_time(self):
        ''' Return status_time '''
        return self._status_time

    @property
    def status_error_current(self):
        ''' Return status_error string '''
        return self._status_error['current']

    @property
    def status_error_last(self):
        ''' Return status_error string '''
        return self._status_error['last']

    @status_error_last.setter
    def status_error_last(self, error):
        ''' Set last status error '''
        self._status_error['last'] = error

    @property
    def offset(self):
        ''' Return time offset '''
        return self._offset

    @offset.setter
    def offset(self, offset):
        ''' Set time offset '''
        self._offset = offset

    @property
    def late(self):
        ''' Return time late '''
        return self._late

    @late.setter
    def late(self, late):
        ''' Set time late '''
        self._late = late

    @property
    def alias(self):
        ''' Get Alias '''

        if not self._alias:
            self._alias = self._config.gateway(self._gw_id).get('alias', self._gw_id)
        return self._alias

    @property
    def gw_id(self):
        ''' Get id '''
        return self._gw_id

    @property
    def name(self):
        """ Pretty print the alias and ID """
        name = self.alias
        if self._gw_id != name:
            name += '(' + self._gw_id + ')'
        return name

    @property
    def activated(self):
        ''' Get name '''
        return self._activated

    @activated.setter
    def activated(self, activated):
        ''' Set frequency plan '''
        self._activated = activated

    @property
    def latitude(self):
        ''' Get name '''
        return self._latitude

    @latitude.setter
    def latitude(self, latitude):
        ''' Set frequency plan '''
        self._latitude = float(latitude)

    @property
    def longitude(self):
        ''' Get name '''
        return self._longitude

    @longitude.setter
    def longitude(self, longitude):
        ''' Set frequency plan '''
        self._longitude = float(longitude)

    @property
    def frequency_plan(self):
        ''' Get name '''
        return self._frequency_plan

    @frequency_plan.setter
    def frequency_plan(self, frequency_plan):
        ''' Set frequency plan '''
        self._frequency_plan = frequency_plan

    def _time(self, timestr):
        ''' Convert to a tm '''

        if timestr is None:
            return timestr

        match = self._TIME_RE.match(timestr)
        if not match:
            return None

        # Convert offset into minutes
        offset = int(match.group('offhour')) * 60
        if offset < 0:
            offset -= int(match.group('offmin'))
        else:
            offset += int(match.group('offmin'))

        tzone = tzoffset(match.group('tzname'), offset * 60)
        result = datetime.datetime(int(match.group('year')),
                                   int(match.group('month')),
                                   int(match.group('day')),
                                   int(match.group('hour')),
                                   int(match.group('minute')),
                                   int(match.group('seconds')),
                                   tzinfo=tzone)
        return result

    @property
    def last_seen(self):
        ''' Get Last seen from info '''

        return self._time(self._info.get('Last seen'))

    @property
    def reported_time(self):
        ''' Get Reported time from info '''

        return self._time(self._info.get('Reported time'))

    @property
    def description(self):
        ''' Get Description from info '''

        return self._info.get('Description.info')

    @property
    def contact_email(self):
        ''' Contact email '''

        return self._config.gateway(self._gw_id).get('to') or self._info.get('Contact email')

    @property
    def cc(self):
        ''' CC list '''

        return self._config.gateway(self._gw_id).get('cc', [])


class Gateways(object):
    ''' Hold and dump/restore a list of Gateways '''

    #        ID              Activated       Frequency Plan  Coordinates
    #1       ttn-ith-test    false           AU_915_928      (42.517288, -76.710183, %!f(int=0))
    _LINE_RE = re.compile(r"^\d+\s+(?P<id>[a-z0-9-]+)\s+(?P<activated>true|false)\s+(?P<frequency_plan>(AU|EU|IN|KR|US|AS)_\d{3}_\d{3})\s+\((?P<lat>-?\d+\.\d+),\s+(?P<long>-?\d+.\d+),.*$")

    def __init__(self, options, config):
        self._options = options
        self._config = config
        self._gateways = dict()
        self._loaded = False
        if options.load:
            try:
                self.load()
            except (EOFError, IOError, pickle.PickleError) as error:
                logging.error(error)

    def load(self):
        ''' Load the list of gateways '''
        filep = open(os.path.expanduser(self._options.statusdb), 'rb')
        self._gateways = pickle.load(filep, encoding='bytes')
        self._loaded = True
        logging.info("Loaded prior status about %d gateways from %s",
                     len(self._gateways),
                     self._options.statusdb)
        filep.close()

    def clear(self):
        ''' Call clear function on each gateway '''
        for gateway in list(self._gateways.values()):
            gateway.clear()

    def save(self):
        ''' Dump the list of gateways '''

        filep = None
        try:
            filep = open(os.path.expanduser(self._options.statusdb), 'wb')
        except IOError as error:
            logging.error(error)
            return

        try:
            pickle.dump(self._gateways, filep, protocol=-1)
        except pickle.PickleError as error:
            logging.error(error)

        if not filep:
            return

        try:
            filep.close()
            logging.info("Wrote prior status to %s", self._options.statusdb)
        except IOError as error:
            logging.error(error)

    def poll(self):
        ''' Update the list of gateways'''

        logging.info("Polling gateways")

        for delay in range(1, 5):
            try:
                self._list()
                break
            except GatewayError as err:
                logging.error(err.args[0])
                time.sleep(delay*30)
            else:
                # XXX - What to do here?
                pass

        logging.info("Found %d gateways:", self._gateways)
        for gateway in list(self._gateways.values()):
            logging.info("\t%s - %s", gateway.name, gateway.description)

        return True

    def _list(self):
        """Return a dict of Gateways"""

        try:
            cmd = [self._options.binary, "gateway", "list"]
            logging.debug("DBG: %s", " ".join(cmd))
            lines = subprocess.check_output(cmd, encoding='UTF-8')
        except OSError as err:
            sys.exit("%s: %s" % (self._options.binary, err))
        except subprocess.CalledProcessError as err:
            logging.info("ERR: %s returns %d", " ".join(cmd), err.returncode)
            raise GatewayError(err.output)

        for gateway in list(self._gateways.values()):
            gateway.save_active()

        for line in lines.split("\n"):
            sline = re.sub(_ANSI_RE, '', line).strip()
            if sline == "":
                continue
            if sline.startswith("INFO "):
                logging.debug("DBG: %s", line)
                continue
            if sline.startswith("FATAL "):
                logging.info(sline)
                raise GatewayError(sline)
            if sline.startswith("ID "):
                continue

            match = self._LINE_RE.match(line)
            if not match:
                continue
            try:
                gateway = self._gateways[match.group('id')]
                gateway.active()
                gateway.frequency_plan = match.group('frequency_plan')
                gateway.latitude = match.group('lat')
                gateway.longitude = match.group('long')
            except KeyError:
                gateway = Gateway(self._options,
                                  self._config,
                                  match.group('id'),
                                  match.group('frequency_plan'),
                                  match.group('lat'),
                                  match.group('long'),
                                  None)
                self._gateways[gateway.gw_id] = gateway
                if self._loaded:
                    gateway.notice("New gateway discovered")
            gateway.activated = bool(match.group('activated'))
            for delay in range(1, 5):
                notice = None
                try:
                    gateway.get_info()
                    break
                except GatewayError as err:
                    notice = err.args[0]
                    logging.error(notice)
                    time.sleep(5*delay)
                else:
                    gateway.notice(notice)

    @property
    def gw_ids(self):
        ''' Return a list of gateway ids '''
        return list(self._gateways.keys())

    @property
    def gateways(self):
        ''' Return a list of gateway objects '''
        return list(self._gateways.values())

    @property
    def gateway(self, gw_id):
        ''' Return a spefic gateway '''
        return self._gateways[gw_id]

def gateway_email(options, user, gateways, alert=True):
    ''' Send e-mail about each gateway '''

    body = dict()
    to = dict()
    cc = dict()

    for gateway in gateways:
        dest = gateway.contact_email or options.fromaddr
        cc_list = set()
        if options.cc:
            cc_list.update(options.cc)
        if gateway.cc:
            cc_list.update(gateway.cc)
        cc_list.add(dest)
        key = hash(",".join(sorted(cc_list)))
        cc_list.discard(dest)
        if key not in to:
            to[key] = dest
        if key not in cc:
            cc[key] = cc_list

        if key not in body:
            body[key] = []

        # Print Alerts
        rest = "\n\t".join(str(x) for x in gateway.notices())

        # Include summary and log if this is daily e-mail
        if not alert:
            rest += "\n\t".join(gateway.pretty())
            if gateway.log:
                rest += "\n\tLog:\n"
                rest += "\n\t".join(str(x) for x in gateway.log)

        body[key].append("gateway %s '%s': \n\t%s" % (gateway.name,
                                                      gateway.description,
                                                      rest))

    for key in list(to.keys()):
        sendmail(options,
                 to.get(key),
                 cc.get(key),
                 "TTN Gateway %s %s" % ("Alert!" if alert else "Summary",
                                        datetime.datetime.now(tzlocal()).strftime("%F %R %Z")),
                 body.get(key))

class User(object):
    """ Get info about user """

    _BRACKETS_RE = re.compile(r'{(.*)}')

    def __init__(self, options):
        """ Get user info """

        self._options = options

        try:
            self._user()
            return
        except UserToken as err:
            if not options.token:
                sys.exit(err.message)
        except UserError as err:
            sys.exit(err.message)

        try:
            if not self._login(options.token):
                sys.exit(1)
            self._user()
        except (UserError, UserToken) as err:
            sys.exit(err.message)

    def _user(self):
        """ Get user info """

        pairs = self._get_response("user")

        for key, value in list(pairs.items()):
            if key == 'Email':
                self._email = value
            elif key == 'Username':
                self._username = value
            elif key == 'Name':
                match = self._BRACKETS_RE.match(value)
                if match:
                    value = match.group(1)
                self._name = value

    def _login(self, token):
        """ Login with token """

        try:
            self._get_response("user", "login", token)
        except (UserError, UserToken) as err:
            logging.error(err.message)
            return False

        return True

    def _get_response(self, *args):
        """ Run command and return keywords """

        cmd = [self._options.binary]
        cmd.extend(args)

        try:
            logging.debug("DBG: %s", " ".join(cmd))
            lines = subprocess.check_output(cmd, encoding='UTF-8')
        except OSError as err:
            raise UserError("%s: %s" % (self._options.binary, err))
        except subprocess.CalledProcessError as err:
            lines = err.output

        pairs = dict()

        for line in lines.split("\n"):
            sline = re.sub(_ANSI_RE, '', line).strip()
            if sline == "":
                continue
            if sline.startswith("INFO"):
                logging.debug("DBG: %s", line)
                continue

            if sline.startswith("FATAL"):
                if sline.find('Please login with ttnctl user login') != -1:
                    raise UserToken("Go to %s to get an OAuth token" % _REGISTER_URL)
                raise UserError(sline)

            match = _INFO_RE.match(line)
            if not match:
                continue

            pairs[match.group('key')] = match.group('value')

        return pairs

    @property
    def email(self):
        """ Return e-mail """
        return self._email

    @property
    def username(self):
        """ Return username """
        return self._username

    @property
    def name(self):
        """ Return name """
        return self._name

def get_ttnctl():
    """ Download and unzip the proper ttnctl for this platform """

    system = os.uname()[0].lower()

    u_arch = os.uname()[4]
    if u_arch == 'x86_64':
        arch = 'amd64'
    elif u_arch == 'i686':
        arch = '386'
    else:
        arch = u_arch
    return "ttnctl-%s-%s" % (system, arch)

def parse_args():
    ''' Argument parsing '''
    parser = argparse.ArgumentParser(description="Monitor TTN gateways", add_help=False)

    # Parse for config file
    group = parser.add_argument_group('optional arguments')
    group.add_argument("-h", "--help",
                       dest="help", default=False,
                       action='store_true',
                       help="show this help message and exit")

    group = parser.add_argument_group("Config file")
    group.add_argument("-C", "--config",
                       dest="config",
                       help="Path to the config file")

    group = parser.add_argument_group("Debugging options")
    group.add_argument("-n", "--noop",
                       dest="noop", default=False,
                       action='store_true',
                       help="Don't make changes, just list what we are going to do")
    group.add_argument("-d", "--debug",
                       dest="debug", default=False,
                       action='store_true',
                       help="print debugging messages")
    group.add_argument("-v", "--verbose",
                       dest="verbose", default=False,
                       action='store_true',
                       help="print verbose messages")
    group.add_argument("-S", "--summary",
                       dest="summary", default=False,
                       action="store_true",
                       help="Print Summary and exit")

    (options, extras) = parser.parse_known_args()

    config = Config(options)

    #	Debugging

    group = parser.add_argument_group("Behavior")
    group.add_argument("--timeout",
                       dest="timeout", type=float, default=config.default('timeout', 300),
                       help="Timeout between polls, in seconds")
    group.add_argument("--late",
                       dest="late", default=config.default('late', 300),
                       help="Interval to mark gateway as not responding")
    group.add_argument("--from",
                       dest="fromaddr", default=config.default('from', None),
                       help="From address for notification emails")
    group.add_argument("--cc",
                       dest="cc", default=config.default('cc', []),
                       action="append",
                       help="List of e-mail cc's")
    group.add_argument("--test",
                       dest="test", default=config.default('test', False),
                       action="store_true",
                       help="Don't send e-mail to victims")
    group.add_argument("--do_summary",
                       dest="do_summary", default=False,
                       action="store_true",
                       help="Send a daily summary")

    #   Other options
    group = parser.add_argument_group("Other options")
    group.add_argument("--token",
                       dest="token",
                       help="OAuth token")
    group.add_argument("--binary",
                       dest="binary",
                       help="Path to binary")
    group.add_argument("--noload",
                       dest="load", default=True,
                       action="store_false",
                       help="Do not resture status from a prior run")
    group.add_argument("--statusdb",
                       dest="statusdb", default="./monitor-status.db",
                       help="Name of status DB")

    options = parser.parse_args(extras, namespace=options)

    # Simpulate help
    if options.help:
        parser.print_help()
        sys.exit(0)

    if options.debug:
        print("ARGS1: %s" % pprint.pformat(options))

    # Debug implies verbose
    if options.debug:
        options.verbose = options.debug

    # From is required
    if not options.fromaddr:
        parser.error('argument --from is required')

    # Find out binary
    if not options.binary:
        for binary in [get_ttnctl(), 'ttnctl']:
            for dirname in [".", os.path.dirname(sys.argv[0])]:
                path = os.path.join(dirname, binary)
                if os.access(path, os.X_OK):
                    options.binary = path
                    break
    if not options.binary:
        parser.error("argument --binary is required if binary is not in current directory")

    if options.debug:
        print("ARGS: %s" % pprint.pformat(options))

    return options, config

def init_logging(options):
    """ Set up logging """

    logger = logging.getLogger()
    logger.handlers = []
    stream = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s %(message)s')
    stream.setFormatter(formatter)
    logger.addHandler(stream)
    if options.debug:
        logger.setLevel('DEBUG')
    elif options.verbose:
        logger.setLevel('INFO')
    else:
        logger.setLevel('WARNING')

    return logger

def main():
    """ Figure out what we should do """

    # Read config file and parse options
    options, config = parse_args()

    init_logging(options)

    # Get user info
    user = User(options)

    # Get the list of gateways
    gateways = Gateways(options, config)

    if options.summary:
        gateways.poll()
        # XXX - Group by group
        for gateway in gateways.gateways:
            if gateway.is_active():
                gateway.get_status()
                logging.warning("%s:\n%s\n", gateway.alias, "\n".join(gateway.pretty()))
        sys.exit(0)

    while gateways.poll():
        alert_gateways = []
        for gateway in gateways.gateways:
            if gateway.was_active != gateway.is_active():
                if gateway.is_active():
                    gateway.notice("Gateway now active")
                else:
                    gateway.notice("Gateway no longer in gateway list")
            elif gateway.is_active():
                gateway.get_status()
                gateway.check_status()

            if gateway.notices():
                logging.info("Need to notify %s about %s: %s",
                             gateway.contact_email or 'someone',
                             gateway.alias,
                             gateway.description)
                alert_gateways.append(gateway)

        gateway_email(options, user, alert_gateways)

        # Save current status
        gateways.save()

        last_time = datetime.datetime.now()
        time.sleep(options.timeout)

        # Send summary at midnight
        if options.do_summary and datetime.datetime.now().hour < last_time.hour:
            gateway_email(options, user, gateways.gateways, alert=False)

        # Clear old notices
        gateways.clear()

if __name__ == "__main__":
    try:
        main()
        sys.exit(0)
    except KeyboardInterrupt:
        print()
        sys.exit(1)

